import requests
import json

# === Retrieve credentials from Databricks secrets ===
client_id     = dbutils.secrets.get(scope="my-graph-scope", key="client-id")
tenant_id     = dbutils.secrets.get(scope="my-graph-scope", key="tenant-id")
client_secret = dbutils.secrets.get(scope="my-graph-scope", key="client-secret")

# === 1. Get access token (client credentials flow) ===
token_url = f"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token"

payload = {
    "client_id": client_id,
    "scope": "https://graph.microsoft.com/.default",
    "client_secret": client_secret,
    "grant_type": "client_credentials"
}

response = requests.post(token_url, data=payload)
response.raise_for_status()
access_token = response.json()["access_token"]
print("✅ Token acquired")

# === 2. Send email ===
user_principal_name = "sender@yourdomain.com"   # ← The mailbox you want to send FROM
graph_url = f"https://graph.microsoft.com/v1.0/users/{user_principal_name}/sendMail"

email_body = {
    "message": {
        "subject": "Test Email from Databricks",
        "body": {
            "contentType": "HTML",
            "content": "<h1>Hello from Databricks!</h1><p>This email was sent via Microsoft Graph API.</p>"
        },
        "toRecipients": [
            {
                "emailAddress": {
                    "address": "recipient@yourdomain.com"
                }
            }
        ],
        # Optional: ccRecipients, bccRecipients
        # Optional: attachments (base64 encoded)
    },
    "saveToSentItems": True
}

headers = {
    "Authorization": f"Bearer {access_token}",
    "Content-Type": "application/json"
}

response = requests.post(graph_url, headers=headers, json=email_body)

if response.status_code == 202:
    print("✅ Email accepted for delivery")
else:
    print(f"❌ Error: {response.status_code}")
    print(response.text)








# ─── Most recommended solution ───

client_id = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"   # ← the ID you see in executed_as

query = f"""
Resources
| where type == 'microsoft.managedidentity/userassignedidentities'
| where properties.clientId == '{client_id}'
| project 
    name,
    resourceGroup,
    subscriptionId,
    principalId,
    clientId,
    id,
    location
"""

from azure.identity import DefaultAzureCredential
from azure.mgmt.resourcegraph import ResourceGraphClient

credential = DefaultAzureCredential()

# If you're using a cluster with UAMI attached → it will be picked up automatically
# Otherwise you can explicitly pass client_id of UAMI you want to use for auth
# credential = DefaultAzureCredential(managed_identity_client_id="your-uami-client-id")

rg_client = ResourceGraphClient(credential)

result = rg_client.resources(
    resources = {
        "query": query,
        "subscriptions": []   # ← empty = search in all accessible subscriptions
    }
)

if result.data:
    for row in result.data:
        print(f"UAMI Name        : {row['name']}")
        print(f"Resource Group   : {row['resourceGroup']}")
        print(f"Client ID        : {row['clientId']}")
        print(f"Object ID        : {row['principalId']}")
        print("-" * 60)
else:
    print("No UAMI found with this client id")







from pyspark.sql.functions import regexp_replace, col

df_clean = df.withColumn(
    "sql_stmt_clean",
    regexp_replace(
        regexp_replace(
            regexp_replace(col("sql_stmt"), r"[\n\r]+", " "),    # newlines → single space
            r"\t+", " "),                                        # tabs → space
        r" +", " "                                               # multiple spaces → single space
    )
)

# Optional: trim + collapse whitespace even more aggressively
# .withColumn("sql_stmt_clean", trim(regexp_replace(col("sql_stmt_clean"), r"\s+", " ")))

display(df_clean.select("id", "sql_stmt_clean", "other_col").limit(20))






# Databricks notebook source
# COMMAND ----------

# ────────────────────────────────────────────────
#          CONFIGURATION - CHANGE THESE
# ────────────────────────────────────────────────

CATALOG_NAME      = "main"                     # or your catalog name
SCHEMA_NAME       = "sales"
TABLE_NAME        = "orders"

DATE_COLUMN       = "order_date"               # ← important: your timestamp/date column name
EMAIL_RECIPIENTS  = ["manager@company.com", "teamlead@company.com"]
EMAIL_SUBJECT     = "Daily Orders Summary – " + dbutils.widgets.text("today", "")

YOUR_SENDER_NAME  = "Databricks Alerts <alerts@yourcompany.com>"

# If you want to use SMTP instead of Databricks email → fill these
USE_SMTP          = False
SMTP_HOST         = "smtp.office365.com"
SMTP_PORT         = 587
SMTP_USER         = "your.email@company.com"
SMTP_PASSWORD     = dbutils.secrets.get("email-secrets", "smtp-password")  # ← recommended

# ────────────────────────────────────────────────
#               1. READ TODAY'S DATA
# ────────────────────────────────────────────────

from pyspark.sql.functions import col, current_date, to_date, lit
from datetime import date

today = date.today()
print(f"Processing date: {today}")

table_full_name = f"{CATALOG_NAME}.{SCHEMA_NAME}.{TABLE_NAME}"

df_today = (
    spark.table(table_full_name)
    .where(to_date(col(DATE_COLUMN)) == lit(today))
    # .where(col(DATE_COLUMN).cast("date") == current_date())   # alternative
)

count = df_today.count()
print(f"Found {count:,} records for today")

if count == 0:
    dbutils.notebook.exit("No records found for today → stopping")

# COMMAND ----------

# ────────────────────────────────────────────────
#               2. BUILD NICE HTML TABLE
# ────────────────────────────────────────────────

# Optional: take a sample or aggregate — here we show raw records (limit to avoid huge emails)
display_limit = 500
pdf = df_today.limit(display_limit).toPandas()

# Convert to HTML with basic but clean styling
html_table = pdf.to_html(
    index=False,
    border=0,
    classes="table table-striped table-hover",
    justify="left"
)

html_content = f"""\
<html>
<head>
  <style>
    body {{ font-family: -apple-system, BlinkMacOSystemFont, 'Segoe UI', Roboto, sans-serif; color: #333; }}
    .header {{ background: #1e3a8a; color: white; padding: 16px; border-radius: 6px 6px 0 0; }}
    .content {{ padding: 20px; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 0 0 6px 6px; }}
    table {{ width: 100%; border-collapse: collapse; }}
    th, td {{ padding: 10px 12px; text-align: left; border-bottom: 1px solid #e5e7eb; }}
    th {{ background: #f3f4f6; font-weight: 600; }}
    .footer {{ margin-top: 24px; font-size: 0.9em; color: #6b7280; }}
  </style>
</head>
<body>
  <div class="header">
    <h2>Daily Orders Report – {today}</h2>
    <p>Found <strong>{count:,}</strong> new orders today</p>
  </div>
  
  <div class="content">
    {html_table}
    
    <div class="footer">
      {'Showing first ' + str(display_limit) + ' rows' if count > display_limit else 'All records shown'}<br>
      Full dataset available in Databricks → {table_full_name}
    </div>
  </div>
</body>
</html>
"""

# COMMAND ----------

# ────────────────────────────────────────────────
#               3. SEND EMAIL
# ────────────────────────────────────────────────

if not USE_SMTP:
    # === Preferred way in Databricks (no credentials needed) ===
    dbutils.notebook.run("/Shared/send_html_email", 120, {
        "subject": f"{EMAIL_SUBJECT} {today}",
        "html_body": html_content,
        "to": ",".join(EMAIL_RECIPIENTS),
        "from_name": YOUR_SENDER_NAME
    })
    print("Email sent using Databricks internal email service")

else:
    # === Classic SMTP way (Outlook 365 / Gmail etc) ===
    import smtplib
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart

    msg = MIMEMultipart("alternative")
    msg["Subject"] = f"{EMAIL_SUBJECT} {today}"
    msg["From"]    = YOUR_SENDER_NAME
    msg["To"]      = ", ".join(EMAIL_RECIPIENTS)

    msg.attach(MIMEText(html_content, "html"))

    try:
        with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
            server.starttls()
            server.login(SMTP_USER, SMTP_PASSWORD)
            server.send_message(msg)
        print("Email sent successfully via SMTP")
    except Exception as e:
        print("SMTP failed:", str(e))

# COMMAND ----------

# Optional: show preview in notebook
displayHTML(html_content[:32000])  # avoid notebook crash with very large tables
